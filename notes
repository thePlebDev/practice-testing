SNAPSHOTS TESTS WITH JEST:
-react already comes with jest
- so the first test that we should write is one that makes sure that our component renders without any errors
- jest lets us use create a snapshot of our rendered component and run this snapshot against future snapshots. When a
future snapshot changes we will get notified during the test. we can either accept the snapshot change or deny it and
investigate the error
- jest stores the snapshots in a folder. Only that way it can show the diff to future snapshots
- this says that we have to install a utility library before we can write snapshot tests. Even the documentation says
that we have to do that. So lets install the stuff.

- the snapshot testing allows us to check and make sure that our UI does not change unexpectedly
- instead of rendering the graphical UI, which would require building the entire app, we can use a test renderer to
quickly generate a serializable value for our React tree.
- so basically with snapshot testing, the first time we create a test, is the first time that the snapshot file
is created and then that snapshot gets used for testing in the future, if the future snapshot is correct then it will
pass and if it is different. it will fail and we can either choose to update it or investigate the error

-snapshot tests are a complement for conventional tests not a replacement. They are not for everything they are
optomized for a different case than normal assertion-based tests

- snapshot testing is prefect for things that are not clearly defined and may change often
- so the snapshot tests are for UI testing mostly

- so when testing we create a test to make sure that it renders correctly and also a snapshot test to make sure that
the ui stays the same way.
- snapshot testing is not test driven development. you get the component working and then you write the test
- it doesnt replace other testing libraries and techniques. We can still use Enzyme and other thing for the TDD
- the .toJSON(); method does exactly what it says it is doing. it turns it into JSON, which makes it easier to store
in the snapshot file.

- the expect(tree).toMatchSnapshot() does two things:
1) if the snapshot already exists it compoares the new snapshot in the tree to the one on disk. if they match, the
test passes. If they don't, the test fails.
2) If a snapshot does not already exist, it creates on, and the test passes

- jest will specific directory, called _snapshots_, for a snapshot that matches the running test file.
- before the snapshot tests we should make sure that the tests run manually

- to the jest testing seems a littl emore specialized to the UI, important but not the main testing that I assume
will be done with Enzyme.

UNIT TESTING WITH ENZYME:
- the unit tests can be used to complement the snapshot tests
- so we install the enzyme dependencies and then we use shallow from enzyme to render the component and make sure
that it renders what we want it to.
-shallow renders the component without child components. this means that we can make the test very dedicated to one
component.
- we should always begin with a shallow test

- to get started with enzyme, we can install it with npm, we also need to install an Adapter corresponding to the version
or react that we have.
- since we are using react 16 we should use the adapter that corresponds to that version.
- jest can be used to test JavaScript logic as integration or unit tests as well.
-for enzyme we have to set enzyme up with is adapter in our jest testing enviroment. Jest offers a setup file to make
this happen. first we need to create this Jest setup file on the command line. jest.setup.js
- so we need to create the setup file called jest.setup.js
- then in the setup file we are going to add some configuration code to make sure that Enzyme plays well with React.
- so I guess we should try to get things set up with enzyme.
- so we know that we have to create a setup file but not 100% sure on where to put it. right now we put it on
the root directory, the same directory as the .gitignore file and we shall see if that works.
- then we add the nessesary lines of code into the file
- in this test file is where we set up the new adapter, we simply import configure and adapter and then

            configure({ adapter: new Adapter() })

- this should set up the new adapter and then we should be free to write test files with enzyme.
- so lets just assume that it is working and start with shallow rendering of a component

SHALLOW RENDERING:
-shallow rendering is useful to constrain ourself to testing a component as a unit. and to ensure that our tests
aren't indirectly asserting behaviour of child components
- so basically shallow rendering lets us just test a single component.

- so jest is our test runner and it makes everything work.
- so right now we have a test to make sure that it renders something and we have a snapshot to make sure the ui is
looking the way that we want it.
- so lets make a test using the shallow api to make sure that the app component renders something useful.

configure jest:
-to actually run the setup file to configure Enzyme and the Adapter with jest,set setupFilesAfterEnv in our
config file, check jests documentation for the possible locations of that config file.
- jests configuration can be defined int he package.json file of our project or through a jest.config. file. so we
are going to use the jest config file.
- so I went into the package.json and setup the correct file paths for the configuration.

- ok so now I am going to try the test to make sure that the app renders one component of the about page.
- then we are going to need some kind of test block, lets read about what the describe is.
- it is actually a testing block from Jest and it creates a group of tests together that are related

- when we are writing a web application a good starting point would be testing every page of the app and every user
interaction. also applications are made of units of code like functions and modules that need to be tested too
- this is how the test flow should look:
1) import the function to test
2) give an input to the function
3) define what to expect as the output
4) check if the function produces the expected output.

- if the component changes often then you should avoid snapshot testing. Snapshot testing is good for components that
don't change often. to put it another way,write a snapshot test when the component is stable

- so if the component has logic or state that changes, then snapshot testing is not the way to go
- the react-test-renderer is a lobrary for rendering React component to pure JavaScript objects, but it can do
alot more than creating objects

-testing the internal implementation of an object is always a bad idea. This holds true for React, Javascript and any
programming language.
- we should test and keep in mind what the user should see. when building user interfaces the development
process is driven by a functional test.
- a functional test(end to end test) is a way to test web applications from the user's perspective.
lets find out what we should tests and then test it.

WHAT SHOULD WE TEST IN REACT:
- the main reason that we write tests is to ensure that the app works the way it should.

1)it must render. At the very least make sure that the component renders the correct thing, given props what should
it output

2) test the states: every conditional should accounted for, if the classNames are conditional, make sure to test that
the className deciding logic is working right.

3) test the events: If the component can be interacted with(clicked changed, or onAnything), test that the events
work as expected

4) test the edge cases:



- for our first example we are using wrapper.containsAllMatchingElements(<patterNodes>) => true. This will return true
wether or not all of the given React elements in patterNodes match an element in the wrapper's render tree.
- so we could use this to make sure that our app component is rendering all the compoents that it is suppose to

- we use the shallow(wrapper) to create a shallow render of the component

- so we have finally figured out a few things, the first being that the enzyme configuration should be in the src folder
and have the name of setupTests.js and then in this file is where we set up the new enzyme adapter.

- then we actually wrote our first test and it is to see that the proper component are contained in the App component.
this is done by using the shallow component to create the wrapper component and then going
wrapper.containsAllMatchingElements([elements]) this will return a boolean and we can use toEqual(true) to see if the test
passes.

TEST 2. CONTAINER STATE:
- for us the container is the App component. so we are going to test the state of the container. So initially it should
contain an empty array of items.
- states are maintained in function compoennts using useState hooks. As the state hooks are interanl to the compoennt
they aren't exposed this they can't be tested by calling them. Thus to test it a stat has updated we simulate events
or call the method props of the compoennt and check if the state has updated by determining the update to the props
of the rendered component, in other words we look for side effects

-simulate: can be used to simulate events ont he root node in the wrapper. it must be a single-node wrapper

-lifecycle hooks such as useEffect aren't yet supported in shallow rendering, so we need to use mount instead of
shallow to test those components for now.

- so when we are testing funcitonal components with hooks we can test them simulating an event and check if the
state has changed

- so lets create a button component and test to see first if it renders and then test to see if it changes a state value
when it gets clicked.
- ok so now we know that the component is rendered, next lets try to test some state using simulate

- first we need to find the button element and then we need to call simulate on it with a click and then we need to
find what we are changing do to the state change and see if that value if the same as what we expect.

- very cool we are now able to test states.

-so now lets try to do some useEffect stuff.
- for useEffect we need to use mount instead of shallow
- mount is a method that re-mounts the component, if it is not currently mounted. this can be used to simulate a
component going through a unmount/mount lifecycle.

HOW TO TEST IN REACT STEP BY STEP:

STEP 1:DESCRIBE IT:
- we should write our describe and out it tests and have them wrote out what we want to do, like rendering or click button
- no actual test are to be written at this point, we just describe what we are about to build

STEP 2: MAKE IT FAIL:
- this step is literaly just make the test fail so that we can fix it

STEP 3: MAKE IT GREEN:
-this is the step where we make the test owrk again
- check that wen you give the app an input it gives the desired ouput


what to test?
- we should test anything that is not static, controlled values, props, states, classNames
-anywhere that we have JSX we need to import React
- for event handlers we can create a spy and a spy is a mocked function that allows us to track its call arguments

Testing a UseEffect hook:
- the trick to shallow testing hooks like useEffect is to use spies. the spies are coming from jest with jest.spyOn().
- the spyOn creates a mock function similar to jest.fn

-a mock function:
- the mock functions allow us to test the links between code by erasing the actual implementation of a function.
capturing calls to the function.

- so the spyOn() method returns a jest mock function.
- when our app is running, useEffect will schedule its effect to be run after the first render. But in a test, most cases
where you're shallow rendering you'd prefer useEffect call its callback immediately, so the effects happen during that
first render.

MOUNT():
- full DOM rendering is ideal for use cases where you have component that may interact with DOM APIs or need to test
components that are wrapped in higher order components.
- this requires a dom, either the actual DOM or a fake on created by something like jsdom

- so when trying to test useEffect, shallow definitely won't work .

- So I think what I am going to do is try and recreate my application but with the tests

- so our app test passed. now lets test to make sure that our app renders with the navBar component.

WHAT CAN BE OMITTED IN TEXT COVERAGE:
-third party libraries
- constants
- inline styles

testing props:
-As a rule, you can divide testing props into two tests . first check the render of default prop values. if the prop has
default prop values. second,check the custom value of the prop; set the value and expect it to be recieved after
the render of the component.

- after creating a snapshot and covering the props with tests, this allows us to be sure in the correct rendering
of the component but it does not give us full coverage. we need to test events and testing events is done in a number
of ways.

- you can go mock event => simulate it=> expect event was called
- mock event => simulate event with params => expect event was called with passed params.
- pass necessary props => render component => simulate event => expect a certain behavior on called event

TESTING STATES:
- the first one checks the current state
- the second one checks state after calling event.

- testing the data types can be done with react.PropTypes
- make sure to use a test coverage tool

MAIN INSTRUCTIONS FOR COMPONENT TESTING:
1) create and test only one snapshot.
2) test the props
3) test the data types
4) test the events
5)test the states

- so with these five things in mind we should be able to cover 90-100% of the code.
- so right now I am testing the props and I am going to see if
- so I should really again read up on the spread operator and the rest parameter. now that I think about it I think
that the rest parameter is the one that is part of the function

TESING THE NAVBAR:
-so we need to import renderer from 'react-test-renderer'
1) create and test the navBar snapshot
2) test the props

REST PARAMETER:
- the rest parameter is indicated by three dots(...) preceding a named parameter. this names parameter becomes an array
containing the rest of the parameters. so ya the rest parameter is the three dots that come before a name parameter in a function
so if we see three dots before a function parameter name, then it is the rest parameter and that name after the array is now
an array that contains all the rest of the paramters

THE SPREAD OPERATOR:
- the spread operator allows us to specify an array that should be split and passed in as separate arguments to a function
so when we say
- so the reason that I am getting undefined has to do with the reason that wehn we call prop on a shallow component, that
component renders not the component itself. to return the props for the entire React component, use wrapper.instance().props

SHALLOW RENDERING:
-this will create a shallow render which means it will not render any of the components children. This makes it faster then mount
which performs a deep render and therefore will render a component and all of its children.
- if you need to test the children of a component then we should use mount, otherwise we should use shallow. children are
just things that are inside of another element
- well mount is under the full dom render API so at least we know that it has something to do with that.
- so I guess we can just get back to testing

- so now I am going to check the event of the button being pressed to open and close the navBar. I am going to do this
but getting the element that the event is happening on and then I am going to simulate a clicked event, then finally I am going
to check to make sure that the class name has changed

- the problem seem to be with the simulate function.
